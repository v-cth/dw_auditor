<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Header with Dot Textures</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --accent: #7c3aed;
      --text: #ffffff;
      --bg: #151515; /* dark background for header */
    }
    html,body { height:100%; margin:0; font-family:Inter, sans-serif; background:#fff; }

    /* Header */
    .header {
      position: relative;
      height: 320px;               /* adjust header height here */
      background: var(--bg);
      overflow: hidden;
      display:flex;
      align-items:flex-end;
      padding: 28px 40px;
      box-sizing: border-box;
      color: var(--text);
    }

    /* Canvas covers the whole header */
    #textureCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display:block;
      z-index: 0;
    }

    /* Content on top */
    .header-inner {
      position: relative;
      z-index: 2;
      width:100%;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
    }

    .brand {
      display:flex;
      flex-direction:column;
      gap:6px;
      color:var(--text);
    }

    .site-title {
      font-size:34px;
      font-weight:700;
      letter-spacing:-0.6px;
      color:var(--text);
      margin:0;
    }

    .site-sub {
      font-size:14px;
      color:rgba(255,255,255,0.85);
      text-transform:uppercase;
      font-weight:600;
      letter-spacing:1px;
    }

    .nav {
      display:flex;
      gap:18px;
      align-items:center;
    }

    .nav a {
      color:rgba(255,255,255,0.92);
      text-decoration:none;
      font-weight:600;
      letter-spacing:0.2px;
    }

    /* subtle frosted panel behind cards (if used later) */
    .overlay {
      position: absolute;
      inset: 0;
      pointer-events:none;
      background: linear-gradient(180deg, rgba(0,0,0,0.08) 0%, transparent 40%);
      z-index:1;
    }

    /* small responsive adjustments */
    @media (max-width:700px){
      .header { height: 260px; padding: 20px; }
      .site-title { font-size:26px; }
      .nav { gap:12px; font-size:14px; }
    }
  </style>
</head>
<body>

  <header class="header" role="banner">
    <canvas id="textureCanvas" aria-hidden="true"></canvas>

    <div class="overlay" aria-hidden="true"></div>

    <div class="header-inner" role="navigation">
      <div class="brand">
        <div class="site-sub">Data Quality</div>
        <h1 class="site-title">Audit Report</h1>
      </div>

      <nav class="nav" aria-label="Main">
        <a href="#">Overview</a>
        <a href="#">Columns</a>
        <a href="#">Relations</a>
        <a href="#">Metadata</a>
      </nav>
    </div>
  </header>

  <main style="padding:28px 40px;">
    <p style="color:#222; margin:0;">Page content goes here...</p>
  </main>

<script>
/*
 Procedural dot-panel texture generator
 - Draws multiple rectangular panels, each filled with a dot grid.
 - Panels vary in density, dot size and randomness to create the mosaic look.
 - Canvas is responsive (resized to devicePixelRatio).
*/

(function(){
  const canvas = document.getElementById('textureCanvas');
  const ctx = canvas.getContext('2d', { alpha: false });

  // Panel layout configuration (you can tweak these)
  const panels = [
    // x%, y%, w%, h%, cellSize(px), dotProb(0..1), dotSizeRatio(0..1)
    [4, 6, 44, 18, 10, 0.88, 0.6],
    [52, 6, 44, 18, 8, 0.7, 0.55],
    [4, 28, 28, 18, 14, 0.9, 0.9],
    [36, 28, 28, 18, 8, 0.6, 0.6],
    [68, 28, 26, 18, 12, 0.5, 0.5],
    [4, 50, 28, 40, 6, 0.45, 0.45],
    [36, 50, 28, 40, 6, 0.55, 0.55],
    [68, 50, 26, 40, 10, 0.72, 0.7]
  ];

  // dark background and dot color
  const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#151515';
  const dotColor = '#F7F7F7'; // white-ish

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }

  function draw(){
    // clear background
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    ctx.fillStyle = bgColor;
    ctx.fillRect(0,0,w,h);

    // add slight global noise/gradient to deepen the background
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, 'rgba(255,255,255,0.02)');
    g.addColorStop(1, 'rgba(0,0,0,0.06)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // draw each panel
    panels.forEach(cfg => {
      drawPanel(cfg[0], cfg[1], cfg[2], cfg[3], cfg[4], cfg[5], cfg[6], w, h);
    });

    // optional: soft vignette edges
    applyVignette(w,h);
  }

  // cfg coords are in percentages
  function drawPanel(px, py, pw, ph, cellSize, dotProb, dotSizeRatio, canvasW, canvasH){
    const x = Math.round((px/100) * canvasW);
    const y = Math.round((py/100) * canvasH);
    const width = Math.round((pw/100) * canvasW);
    const height = Math.round((ph/100) * canvasH);

    // slightly rounded rectangle as panel background (darker)
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    roundRect(ctx, x, y, width, height, 6);
    ctx.fill();

    // dot grid: compute rows & cols by cell size
    const cols = Math.ceil(width / cellSize);
    const rows = Math.ceil(height / cellSize);
    const jitter = cellSize * 0.22; // random jitter within a cell

    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        // probability: vary slightly by noise so patterns aren't uniform
        const noise = (Math.sin((x+c*13)+ (y+r*7)) + 1)/2; // deterministic-ish noise
        const prob = dotProb * (0.85 + 0.3 * (noise - 0.5));

        if(Math.random() < prob){
          // position within panel cell (center + jitter)
          const cx = x + c * cellSize + cellSize*0.5 + (Math.random()*2-1)*jitter;
          const cy = y + r * cellSize + cellSize*0.5 + (Math.random()*2-1)*jitter;

          // dot size varies a bit
          const dotR = Math.max(0.8, (cellSize * dotSizeRatio) * (0.8 + Math.random()*0.6) );
          // circular dot
          ctx.beginPath();
          ctx.fillStyle = dotColor;
          ctx.globalAlpha = 0.98 - Math.random()*0.12; // subtle alpha variance
          ctx.arc(cx, cy, dotR/2, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    // reset alpha
    ctx.globalAlpha = 1;
  }

  function applyVignette(w,h){
    // subtle darkening around corners
    const vg = ctx.createRadialGradient(w*0.5, h*0.5, Math.min(w,h)*0.2, w*0.5, h*0.5, Math.max(w,h));
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.22)');
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,w,h);
  }

  // rounded rect helper
  function roundRect(ctx,x,y,w,h,r){
    const radius = typeof r === 'number' ? r : 6;
    ctx.beginPath();
    ctx.moveTo(x+radius,y);
    ctx.arcTo(x+w,y, x+w,y+h, radius);
    ctx.arcTo(x+w,y+h, x,y+h, radius);
    ctx.arcTo(x,y+h, x,y, radius);
    ctx.arcTo(x,y, x+w,y, radius);
    ctx.closePath();
  }

  // initial draw + resize listener (debounced)
  let resizeTimer;
  function handleResize(){
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(resizeCanvas, 80);
  }

  window.addEventListener('resize', handleResize);
  // initial call
  resizeCanvas();

  // optional: animate (subtle). Toggle off for static texture.
  // small subtle animation: every few seconds, nudge panels slightly
  let anim = true;
  if(anim){
    setInterval(()=>{
      // re-seed patterns by re-drawing (makes randomness change slowly)
      draw();
    }, 3800); // redraw every 3.8s for gentle life
  }

})();
</script>

</body>
</html>
